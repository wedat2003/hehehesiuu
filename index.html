<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>For Nefise</title>
  <style>
    :root {
      --bg-1: #130611;
      --bg-2: #3a1330;
      --bg-3: #5d1f45;
      --text: #fff6fb;
      --soft: #ffd9ec;
      --rose-a: #ff76b2;
      --rose-b: #e35192;
      --lily-a: #fff9ef;
      --lily-b: #ffe2bf;
      --stem: #6ab17c;
      --wrap: #e8d7b8;
      --ribbon: #d97fab;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      color: var(--text);
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, "Times New Roman", serif;
      background: radial-gradient(circle at 20% 10%, var(--bg-3), var(--bg-1) 56%);
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    body::before {
      background:
        radial-gradient(circle at 15% 15%, rgba(255, 170, 215, 0.18), transparent 42%),
        radial-gradient(circle at 84% 25%, rgba(255, 208, 150, 0.16), transparent 44%),
        radial-gradient(circle at 50% 90%, rgba(255, 130, 190, 0.1), transparent 55%);
      animation: bgFloat 10s ease-in-out infinite alternate;
    }

    body::after {
      background-image:
        linear-gradient(115deg, rgba(255, 255, 255, 0.03) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.03) 50%, rgba(255, 255, 255, 0.03) 75%, transparent 75%);
      background-size: 140px 140px;
      opacity: 0.2;
    }

    @keyframes bgFloat {
      from { transform: translate3d(-2%, -1%, 0) scale(1); }
      to { transform: translate3d(2%, 1%, 0) scale(1.08); }
    }

    #scene {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .intro {
      position: fixed;
      inset: 0;
      z-index: 12;
      display: grid;
      place-items: center;
      background: linear-gradient(160deg, rgba(13, 4, 17, 0.95), rgba(58, 17, 43, 0.95));
      transition: opacity 1.2s ease, transform 1.2s ease;
    }

    .intro.hidden {
      opacity: 0;
      transform: scale(1.04);
      pointer-events: none;
    }

    .intro-card {
      width: min(92vw, 760px);
      padding: clamp(1.2rem, 3vw, 2.2rem);
      border-radius: 24px;
      border: 1px solid rgba(255, 214, 236, 0.33);
      background: rgba(255, 255, 255, 0.08);
      box-shadow: 0 28px 80px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(7px);
      max-height: min(86vh, 920px);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }

    .title {
      margin: 0 0 0.5rem;
      text-align: center;
      color: var(--soft);
      font-size: clamp(1.9rem, 4.6vw, 3.4rem);
      letter-spacing: 0.03em;
      text-shadow: 0 8px 26px rgba(255, 125, 180, 0.45);
    }

    .typewriter {
      min-height: 220px;
      line-height: 1.65;
      font-size: clamp(1.03rem, 2.2vw, 1.22rem);
      white-space: pre-wrap;
      color: #fff4fb;
      opacity: 0.98;
    }

    .cursor {
      display: inline-block;
      margin-left: 3px;
      width: 10px;
      color: var(--soft);
      animation: blink 0.75s steps(1) infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    .intro-cta {
      display: flex;
      justify-content: center;
      margin-top: 1.2rem;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.6s ease, transform 0.6s ease;
      pointer-events: none;
    }

    .intro-cta.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .intro-cta button {
      border: none;
      border-radius: 999px;
      padding: 0.85rem 1.6rem;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      color: #45162d;
      background: linear-gradient(135deg, #ffddee, #ffcdb2);
      box-shadow: 0 12px 24px rgba(255, 143, 193, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .intro-cta button:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 32px rgba(255, 143, 193, 0.45);
    }

    .love-note {
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%);
      width: min(94vw, 900px);
      z-index: 5;
      opacity: 0;
      transition: opacity 1.2s ease;
      text-align: center;
      padding: 0.72rem 1rem;
      border-radius: 14px;
      border: 1px solid rgba(255, 212, 230, 0.35);
      background: rgba(19, 6, 17, 0.58);
      backdrop-filter: blur(5px);
      font-size: clamp(0.92rem, 2vw, 1.2rem);
      letter-spacing: 0.02em;
    }

    .love-note.show {
      opacity: 1;
    }

    @media (max-width: 700px) {
      .intro {
        align-items: start;
        overflow-y: auto;
        padding: max(14px, env(safe-area-inset-top)) 10px max(14px, env(safe-area-inset-bottom));
      }
      .intro-card {
        width: 100%;
        max-height: none;
        margin: 0;
        padding: 1rem 0.9rem 0.9rem;
        border-radius: 18px;
      }
      .typewriter {
        min-height: 360px;
      }
      .intro-cta {
        position: sticky;
        bottom: 0;
        padding-top: 0.6rem;
        padding-bottom: max(0.4rem, env(safe-area-inset-bottom));
        background: linear-gradient(to top, rgba(46, 16, 36, 0.92), rgba(46, 16, 36, 0.15));
      }
      .love-note {
        bottom: 12px;
      }
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <section class="intro" id="intro">
    <article class="intro-card">
      <h1 class="title">For Nefise</h1>
      <div id="typed" class="typewriter"></div>
      <div class="intro-cta" id="cta">
        <button id="startBtn" type="button">Let my bouquet bloom for you</button>
      </div>
    </article>
  </section>

  <div class="love-note" id="note">
    Happy Valentine's Day, my love. Our first one and hoping for many more.
  </div>

  <script>
    const intro = document.getElementById('intro');
    const typed = document.getElementById('typed');
    const cta = document.getElementById('cta');
    const startBtn = document.getElementById('startBtn');
    const note = document.getElementById('note');

    const introLines = [
      'Nefise,',
      '',
      'I did not want to send you only a few words today.',
      'I wanted to give you something that feels like closeness, even while we are far from each other.',
      '',
      'It is hard not having you right here with me.',
      'But what is even stronger is how deeply I love you, no matter how many kilometers are between us.',
      '',
      'Every day with you, every memory, every look from you stays with me.',
      'And I promise you this: my love for you is never small and never short.',
      'It stays. It grows. It always finds its way back to you.',
      '',
      "Happy Valentine's Day, my love.",
      'Our first one, and I hope for many more with you. ',
      '',
      'This little garden is only one sign of that.',
      'When you are ready, press the button.'
    ];

    let lineIndex = 0;
    let charIndex = 0;
    let typingDone = false;

    function typeIntro() {
      if (typingDone) return;

      const full = introLines[lineIndex] ?? '';
      const current = full.slice(0, charIndex);

      const previous = introLines
        .slice(0, lineIndex)
        .join('\n');

      typed.innerHTML = `${previous}${previous ? '\n' : ''}${current}<span class="cursor">|</span>`;

      charIndex += 1;

      if (charIndex > full.length) {
        lineIndex += 1;
        charIndex = 0;
      }

      if (lineIndex >= introLines.length) {
        typingDone = true;
        typed.innerHTML = `${introLines.join('\n')}<span class="cursor">|</span>`;
        cta.classList.add('visible');
        return;
      }

      const delay = full.length === 0 ? 280 : (30 + Math.random() * 36);
      setTimeout(typeIntro, delay);
    }

    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');

    let w = 0;
    let h = 0;
    let t = 0;
    let running = false;
    let bouquetScale = 1;
    let isSmallScreen = false;

    const flowers = [];
    const petals = [];
    const sparks = [];

    function resize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      w = window.innerWidth;
      h = window.innerHeight;
      isSmallScreen = w <= 700;
      const shortSide = Math.min(w, h);
      bouquetScale = isSmallScreen
        ? Math.max(0.68, Math.min(0.92, shortSide / 470))
        : 1;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = `${w}px`;
      canvas.style.height = `${h}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    class Flower {
      constructor(kind, angle, radius, row) {
        this.kind = kind;
        this.angle = angle;
        this.radius = radius;
        this.row = row;
        this.phase = Math.random() * Math.PI * 2;
        this.open = 0;
        this.speed = 0.004 + Math.random() * 0.003;
        this.baseYOffset = (Math.random() - 0.5) * 3;
        this.stemCurveOffset = Math.sin(this.phase) * 22;
        this.kindLift = kind === 'lily' ? -18 : 0;
      }

      update(dt) {
        this.open = Math.min(1, this.open + dt * this.speed);
      }

      draw(time) {
        const bunchX = w * 0.5;
        const bunchY = h * (isSmallScreen ? 0.78 : 0.84);

        const arcX = w * 0.5;
        const arcY = h * (isSmallScreen ? 0.42 : 0.47);

        // Symmetric bouquet arc: left/right spread from angle, vertical depth from cosine.
        const scaledRadius = this.radius * bouquetScale;
        const xOffset = Math.sin(this.angle) * scaledRadius;
        const yOffset = -Math.cos(this.angle) * scaledRadius * 0.42 + this.row * (38 * bouquetScale) + 10 + (this.kindLift * bouquetScale);
        const sway = Math.sin(time * 0.001 + this.phase) * (1.1 + this.row * 0.45);

        const fx = arcX + xOffset + sway;
        const fy = arcY + yOffset;

        const baseX = bunchX + this.angle * (40 * bouquetScale);
        const baseY = bunchY + this.baseYOffset;
        const cx = (baseX + fx) * 0.5 + (this.stemCurveOffset * bouquetScale) + Math.sin(time * 0.0007 + this.phase) * 3;
        const cy = (baseY + fy) * 0.52;

        ctx.strokeStyle = 'rgba(106, 177, 124, 0.96)';
        ctx.lineWidth = Math.max(1.8, 3 * bouquetScale);
        ctx.beginPath();
        ctx.moveTo(baseX, baseY);
        ctx.quadraticCurveTo(cx, cy, fx, fy);
        ctx.stroke();

        // Botanical-style leaves:
        // - peony: larger compound leaves with broad leaflets
        // - lily: multiple narrow lanceolate leaves along the stem
        if (this.kind === 'peony') {
          drawPeonyCompoundLeaf(baseX, baseY, cx, cy, fx, fy, 0.35, this.angle < 0 ? 1 : -1, (1.15 + this.row * 0.1) * bouquetScale, time, this.phase);
          drawPeonyCompoundLeaf(baseX, baseY, cx, cy, fx, fy, 0.62, this.angle < 0 ? -1 : 1, (1.0 + this.row * 0.08) * bouquetScale, time, this.phase + 0.8);
        } else {
          drawLilyStemLeaves(baseX, baseY, cx, cy, fx, fy, 0.24, 0.38, 0.52, 0.66, 0.79, (1.1 + this.row * 0.08) * bouquetScale, time, this.phase);
        }

        const size = this.kind === 'peony'
          ? (44 + this.row * 8) * bouquetScale
          : (38 + this.row * 6) * bouquetScale;
        const r = size * this.open;

        if (this.kind === 'peony') {
          drawPeony(fx, fy, r, time, this.phase);
        } else {
          drawLily(fx, fy, r, time, this.phase);
        }
      }
    }

    function quadPoint(p0, p1, p2, tPos) {
      const mt = 1 - tPos;
      return (mt * mt * p0) + (2 * mt * tPos * p1) + (tPos * tPos * p2);
    }

    function quadTangent(p0, p1, p2, tPos) {
      return (2 * (1 - tPos) * (p1 - p0)) + (2 * tPos * (p2 - p1));
    }

    function leafNoise(seed, idx, min, max) {
      const n = (Math.sin(seed * 2.73 + idx * 1.97) + 1) * 0.5;
      return min + (max - min) * n;
    }

    function drawLeafShape(x, y, angle, len, wid, colorA, colorB, veinColor) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      const g = ctx.createLinearGradient(0, 0, len, 0);
      g.addColorStop(0, colorA);
      g.addColorStop(1, colorB);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(len * 0.44, -wid, len, 0);
      ctx.quadraticCurveTo(len * 0.41, wid * 0.82, 0, 0);
      ctx.fill();

      ctx.strokeStyle = veinColor;
      ctx.lineWidth = Math.max(0.8, wid * 0.11);
      ctx.beginPath();
      ctx.moveTo(1, 0);
      ctx.lineTo(len * 0.88, 0);
      ctx.stroke();

      ctx.restore();
    }

    function drawPeonyCompoundLeaf(x0, y0, x1, y1, x2, y2, tPos, side, scale, time, phase) {
      const x = quadPoint(x0, x1, x2, tPos);
      const y = quadPoint(y0, y1, y2, tPos);
      const dx = quadTangent(x0, x1, x2, tPos);
      const dy = quadTangent(y0, y1, y2, tPos);
      const stemAngle = Math.atan2(dy, dx);
      const flutter = Math.sin(time * 0.0011 + phase + tPos * 6) * 0.045;
      const branchSpread = 0.48 + leafNoise(phase, tPos * 10, 0.0, 0.22);
      const branchAngle = stemAngle + (side > 0 ? -branchSpread : branchSpread) + flutter;

      const petioleLen = 10 * scale * leafNoise(phase, 12 + tPos * 9, 0.85, 1.2);
      const bx = x + Math.cos(branchAngle) * petioleLen;
      const by = y + Math.sin(branchAngle) * petioleLen;

      ctx.strokeStyle = 'rgba(92, 160, 90, 0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(bx, by);
      ctx.stroke();

      // Tri-foliate look: one central broad leaflet + two side leaflets.
      const centerMul = scale * leafNoise(phase, 21 + tPos * 10, 0.92, 1.24);
      const sideMulA = scale * leafNoise(phase, 31 + tPos * 10, 0.78, 1.1);
      const sideMulB = scale * leafNoise(phase, 41 + tPos * 10, 0.78, 1.1);

      drawLeafShape(
        bx,
        by,
        branchAngle + side * 0.06,
        30 * centerMul,
        10.5 * centerMul,
        'rgba(154, 214, 144, 0.96)',
        'rgba(66, 122, 72, 0.95)',
        'rgba(228, 255, 230, 0.34)'
      );
      drawLeafShape(
        bx - Math.cos(branchAngle) * (2.8 * scale),
        by - Math.sin(branchAngle) * (2.8 * scale),
        branchAngle + side * 0.56,
        24 * sideMulA,
        8.7 * sideMulA,
        'rgba(143, 206, 136, 0.95)',
        'rgba(61, 114, 70, 0.94)',
        'rgba(220, 248, 224, 0.3)'
      );
      drawLeafShape(
        bx - Math.cos(branchAngle) * (2.8 * scale),
        by - Math.sin(branchAngle) * (2.8 * scale),
        branchAngle - side * 0.54,
        24 * sideMulB,
        8.7 * sideMulB,
        'rgba(143, 206, 136, 0.95)',
        'rgba(61, 114, 70, 0.94)',
        'rgba(220, 248, 224, 0.3)'
      );
    }

    function drawLilyLeafAt(x0, y0, x1, y1, x2, y2, tPos, side, scale, spread, time, phase) {
      const x = quadPoint(x0, x1, x2, tPos);
      const y = quadPoint(y0, y1, y2, tPos);
      const dx = quadTangent(x0, x1, x2, tPos);
      const dy = quadTangent(y0, y1, y2, tPos);
      const stemAngle = Math.atan2(dy, dx);
      const flutter = Math.sin(time * 0.00125 + phase + tPos * 7) * 0.035;
      const cant = 0.28 + spread + leafNoise(phase, tPos * 100 + side * 3, -0.05, 0.06);
      const leafAngle = stemAngle + (side > 0 ? -cant : cant) + flutter;
      const lenMul = leafNoise(phase, tPos * 120 + side * 11, 0.84, 1.26);
      const widMul = leafNoise(phase, tPos * 90 + side * 7, 0.78, 1.16);
      const normal = stemAngle + (side > 0 ? -Math.PI / 2 : Math.PI / 2);
      const offset = 1.6 + leafNoise(phase, tPos * 70 + side * 5, 0.0, 2.2);
      const lx = x + Math.cos(normal) * offset;
      const ly = y + Math.sin(normal) * offset;

      drawLeafShape(
        lx,
        ly,
        leafAngle,
        28 * scale * lenMul,
        4.8 * scale * widMul,
        'rgba(161, 218, 148, 0.96)',
        'rgba(73, 133, 80, 0.95)',
        'rgba(226, 255, 226, 0.3)'
      );
    }

    function drawLilyStemLeaves(x0, y0, x1, y1, x2, y2, t1, t2, t3, t4, t5, scale, time, phase) {
      // Lily leaves are narrow linear-lanceolate and repeat along the stem.
      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t1, 1, scale, -0.14, time, phase);
      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t1, -1, scale, 0.10, time, phase);

      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t2, -1, scale * 0.98, -0.12, time, phase);
      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t2, 1, scale * 0.98, 0.11, time, phase);

      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t3, 1, scale * 0.95, -0.09, time, phase);
      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t3, -1, scale * 0.95, 0.12, time, phase);

      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t4, -1, scale * 0.93, -0.08, time, phase);
      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t4, 1, scale * 0.93, 0.1, time, phase);

      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t5, 1, scale * 0.9, -0.06, time, phase);
      drawLilyLeafAt(x0, y0, x1, y1, x2, y2, t5, -1, scale * 0.9, 0.08, time, phase);
    }

    function drawPeony(x, y, r, time, phase) {
      const layers = [
        { count: 10, spread: 0.98, w: 0.44, h: 0.68, c1: 'rgba(255, 214, 234, 0.98)', c2: 'rgba(255, 153, 201, 0.93)' },
        { count: 13, spread: 0.84, w: 0.39, h: 0.62, c1: 'rgba(255, 196, 225, 0.97)', c2: 'rgba(247, 129, 186, 0.92)' },
        { count: 16, spread: 0.70, w: 0.34, h: 0.56, c1: 'rgba(255, 182, 217, 0.96)', c2: 'rgba(236, 106, 170, 0.91)' },
        { count: 18, spread: 0.57, w: 0.29, h: 0.48, c1: 'rgba(255, 166, 208, 0.95)', c2: 'rgba(224, 84, 153, 0.9)' },
        { count: 20, spread: 0.44, w: 0.24, h: 0.40, c1: 'rgba(248, 147, 197, 0.95)', c2: 'rgba(210, 70, 141, 0.9)' }
      ];

      const shadow = ctx.createRadialGradient(x, y, r * 0.22, x, y, r * 1.35);
      shadow.addColorStop(0, 'rgba(175, 44, 112, 0.2)');
      shadow.addColorStop(1, 'rgba(175, 44, 112, 0)');
      ctx.fillStyle = shadow;
      ctx.beginPath();
      ctx.ellipse(x, y + r * 0.08, r * 1.16, r * 0.86, 0, 0, Math.PI * 2);
      ctx.fill();

      for (let layer = 0; layer < layers.length; layer++) {
        const layerCfg = layers[layer];
        for (let i = 0; i < layerCfg.count; i++) {
          const a = (Math.PI * 2 / layerCfg.count) * i + Math.sin(time * 0.0012 + i + phase) * 0.035;
          const pulse = 0.93 + Math.sin(time * 0.0016 + i * 0.7 + phase + layer) * 0.07;
          const rr = r * layerCfg.spread * pulse;
          const px = x + Math.cos(a) * rr * 0.58;
          const py = y + Math.sin(a) * rr * 0.43 - layer * 0.5;

          const pw = Math.max(2, r * layerCfg.w);
          const ph = Math.max(2, r * layerCfg.h);

          const g = ctx.createRadialGradient(px - pw * 0.25, py - ph * 0.22, 1, px, py, ph);
          g.addColorStop(0, layerCfg.c1);
          g.addColorStop(1, layerCfg.c2);

          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(a + Math.PI / 2 + Math.sin(time * 0.0009 + i + layer) * 0.06);
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.ellipse(0, 0, pw, ph, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(255, 240, 248, 0.2)';
          ctx.lineWidth = 0.7;
          ctx.stroke();
          ctx.restore();
        }
      }

      for (let i = 0; i < 14; i++) {
        const a = (Math.PI * 2 / 14) * i + Math.sin(time * 0.0018 + i) * 0.09;
        const px = x + Math.cos(a) * r * 0.18;
        const py = y + Math.sin(a) * r * 0.14;
        const g = ctx.createRadialGradient(px, py, 1, px, py, r * 0.18);
        g.addColorStop(0, 'rgba(255, 214, 232, 0.98)');
        g.addColorStop(1, 'rgba(231, 103, 171, 0.92)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.ellipse(px, py, r * 0.12, r * 0.18, a, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = 'rgba(255, 232, 168, 0.97)';
      ctx.beginPath();
      ctx.arc(x, y, Math.max(2, r * 0.13), 0, Math.PI * 2);
      ctx.fill();

      for (let i = 0; i < 16; i++) {
        const a = (Math.PI * 2 / 16) * i;
        const sx = x + Math.cos(a) * r * 0.18;
        const sy = y + Math.sin(a) * r * 0.16;
        ctx.fillStyle = 'rgba(255, 201, 105, 0.92)';
        ctx.beginPath();
        ctx.arc(sx, sy, 1.2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawLily(x, y, r, time, phase) {
      const petalsCount = 6;
      for (let i = 0; i < petalsCount; i++) {
        const a = (Math.PI * 2 / petalsCount) * i + Math.sin(time * 0.0011 + phase + i) * 0.05;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(a);

        const g = ctx.createLinearGradient(0, 0, 0, -r * 1.2);
        g.addColorStop(0, 'rgba(255, 249, 239, 0.98)');
        g.addColorStop(1, 'rgba(255, 226, 191, 0.85)');

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(r * 0.56, -r * 0.45, 0, -r * 1.16);
        ctx.quadraticCurveTo(-r * 0.56, -r * 0.45, 0, 0);
        ctx.fill();

        ctx.strokeStyle = 'rgba(240, 189, 130, 0.6)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(0, -r * 0.15);
        ctx.lineTo(0, -r * 0.95);
        ctx.stroke();

        ctx.restore();
      }

      for (let j = 0; j < 5; j++) {
        const sa = (Math.PI * 2 / 5) * j + Math.sin(time * 0.0019 + j) * 0.08;
        const sx = x + Math.cos(sa) * r * 0.18;
        const sy = y + Math.sin(sa) * r * 0.18;
        const ex = sx + Math.cos(sa) * r * 0.33;
        const ey = sy + Math.sin(sa) * r * 0.33;

        ctx.strokeStyle = 'rgba(156, 109, 43, 0.95)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();

        ctx.fillStyle = 'rgba(255, 207, 112, 0.96)';
        ctx.beginPath();
        ctx.arc(ex, ey, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Petal {
      constructor(initial = false) {
        this.reset(initial);
      }

      reset(initial = false) {
        this.x = Math.random() * w;
        this.y = initial ? Math.random() * h : -24;
        this.vx = -0.18 + Math.random() * 0.45;
        this.vy = 0.7 + Math.random() * 1.2;
        this.spin = -0.02 + Math.random() * 0.04;
        this.rot = Math.random() * Math.PI * 2;
        this.size = 4 + Math.random() * 8;
        this.color = Math.random() > 0.5 ? 'rgba(255, 194, 224, 0.83)' : 'rgba(255, 239, 221, 0.83)';
      }

      update(time) {
        this.x += this.vx + Math.sin(time * 0.002 + this.y * 0.02) * 0.16;
        this.y += this.vy;
        this.rot += this.spin;

        if (this.y > h + 30 || this.x < -40 || this.x > w + 40) {
          this.reset(false);
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rot);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size * 0.64, this.size, Math.PI / 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class Spark {
      constructor() {
        this.x = Math.random() * w;
        this.y = Math.random() * h;
        this.r = 1 + Math.random() * 2;
        this.phase = Math.random() * Math.PI * 2;
      }

      draw(time) {
        const a = 0.25 + (Math.sin(time * 0.002 + this.phase) + 1) * 0.32;
        ctx.fillStyle = `rgba(255, 245, 222, ${a.toFixed(3)})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function seedScene() {
      flowers.length = 0;
      petals.length = 0;
      sparks.length = 0;

      const rows = isSmallScreen
        ? [
            { count: 6, radius: Math.min(w * 0.24, 200), row: 0 },
            { count: 5, radius: Math.min(w * 0.18, 162), row: 1 },
            { count: 4, radius: Math.min(w * 0.135, 126), row: 2 }
          ]
        : [
            { count: 7, radius: Math.min(w * 0.25, 235), row: 0 },
            { count: 6, radius: Math.min(w * 0.19, 192), row: 1 },
            { count: 5, radius: Math.min(w * 0.14, 148), row: 2 }
          ];

      rows.forEach((group, gi) => {
        for (let i = 0; i < group.count; i++) {
          const u = group.count === 1 ? 0.5 : i / (group.count - 1);
          const angle = -1.25 + u * 2.5 + (Math.random() - 0.5) * 0.08;
          const kind = (i + gi) % 2 === 0 ? 'peony' : 'lily';
          flowers.push(new Flower(kind, angle, group.radius + (Math.random() - 0.5) * 18, group.row));
        }
      });

      for (let i = 0; i < (isSmallScreen ? 52 : 75); i++) petals.push(new Petal(true));
      for (let i = 0; i < (isSmallScreen ? 70 : 90); i++) sparks.push(new Spark());
    }

    function drawBackground(time) {
      const pulse = Math.sin(time * 0.00028) * 0.5 + 0.5;
      const g = ctx.createLinearGradient(0, 0, w, h);
      g.addColorStop(0, `rgba(${18 + Math.floor(16 * pulse)}, 6, 17, 1)`);
      g.addColorStop(0.55, `rgba(${58 + Math.floor(18 * pulse)}, 19, 48, 1)`);
      g.addColorStop(1, `rgba(${93 + Math.floor(15 * pulse)}, 31, 69, 1)`);

      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      sparks.forEach((s) => s.draw(time));
    }

    function drawWrap() {
      const cx = w * 0.5;
      const by = h * (isSmallScreen ? 0.78 : 0.84);
      const wrapScale = isSmallScreen ? Math.max(0.78, bouquetScale * 0.95) : 1;
      const halfTop = 170 * wrapScale;
      const halfBottom = 94 * wrapScale;
      const topY = by - 12 * wrapScale;

      ctx.fillStyle = 'rgba(232, 215, 184, 0.95)';
      ctx.strokeStyle = 'rgba(206, 179, 128, 0.9)';
      ctx.lineWidth = Math.max(1.5, 2 * wrapScale);
      ctx.beginPath();
      ctx.moveTo(cx - halfTop, topY);
      ctx.lineTo(cx + halfTop, topY);
      ctx.lineTo(cx + halfBottom, h + 8);
      ctx.lineTo(cx - halfBottom, h + 8);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = 'rgba(217, 127, 171, 0.95)';
      ctx.fillRect(cx - 92 * wrapScale, by - 16 * wrapScale, 184 * wrapScale, 26 * wrapScale);

      ctx.fillStyle = '#fff6fb';
      ctx.font = `bold ${Math.max(12, Math.round(16 * wrapScale))}px Georgia, serif`;
      ctx.textAlign = 'center';
      ctx.fillText('Nefise', cx, by + (2 * wrapScale));
    }

    function animate(now) {
      if (!running) return;

      const dt = Math.min(33, now - t || 16);
      t = now;

      drawBackground(now);

      flowers
        .slice()
        .sort((a, b) => {
          if (a.row !== b.row) return a.row - b.row;
          if (a.kind === b.kind) return 0;
          return a.kind === 'peony' ? -1 : 1;
        })
        .forEach((f) => {
          f.update(dt);
          f.draw(now);
        });

      petals.forEach((p) => {
        p.update(now);
        p.draw();
      });

      drawWrap();
      requestAnimationFrame(animate);
    }

    startBtn.addEventListener('click', () => {
      intro.classList.add('hidden');
      setTimeout(() => note.classList.add('show'), 900);

      if (!running) {
        running = true;
        seedScene();
        t = performance.now();
        requestAnimationFrame(animate);
      }
    });

    window.addEventListener('resize', () => {
      resize();
      seedScene();
    });

    resize();
    seedScene();
    typeIntro();
  </script>
</body>
</html>
